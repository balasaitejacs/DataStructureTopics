Question:
Write a very simple functions for Depth First Search and Breadth First Search.

Note: 
//Another URL for Depth-First Search using Push and Pop with details
//URL contains: Depth-First Search; Tracing the Path of Depth-First Search;
//URL: https://www.koderdojo.com/blog/depth-first-search-algorithm-in-csharp-and-net-core

//Another URL for Breadth-First Search using Push and Pop with details
//URL contains: Breadth-First Search; Tracing the Path of Breadth-First Search; Shortest Path Using Breadth-First Search
//URL: https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core

Answer:
using System;
using System.Collections.Generic;
using System.Linq;

namespace Amazon
{
    public class Graph
    {
        public class Node
        {
            public int id;
            public LinkedList<Node> adjacent = new LinkedList<Node>();
            public Node(int id)
            {
                this.id = id;
            }
        }

        private Node getNode(int id)
        {
            Node node = new Node(id);
            return node;
        }

        public void addEdge(int source, int destination)
        {
            Node s = getNode(source);
            Node d = getNode(destination);
            s.adjacent.AddLast(d);
        }

        public Boolean hasPathDFS(int source, int destination)
        {
            Node s = getNode(source);
            Node d = getNode(destination);
            HashSet<int> visited = new HashSet<int>();
            return hasPathDFS(s, d, visited);
        }

        private Boolean hasPathDFS(Node source, Node destination, HashSet<int> visited)
        {
            if(visited.Contains(source.id))
            {
                return false;
            }
            visited.Add(source.id);
            if(source == destination)
            {
                return true;
            }

            foreach(Node child in source.adjacent)
            {
                if(hasPathDFS(child, destination, visited))
                {
                    return true;
                }
            }
            return false;
        }

        public Boolean hasPathBFS(int source, int destination)
        {
            return hasPathBFS(getNode(source), getNode(destination));
        }

        private Boolean hasPathBFS(Node source, Node destination)
        {
            Queue<Node> nextToVisit = new Queue<Node>();
            HashSet<int> visited = new HashSet<int>();
            nextToVisit.Enqueue(source);
            while (nextToVisit.Count() != 0)
            {
                Node node = nextToVisit.Dequeue();
                if(node == destination)
                {
                    return true;
                }

                if(visited.Contains(node.id))
                {
                    continue;
                }
                visited.Add(node.id);
 
                foreach(Node child in node.adjacent)
                {
                    nextToVisit.Enqueue(child);
                }
            }
            return false;
        }

    }
}
